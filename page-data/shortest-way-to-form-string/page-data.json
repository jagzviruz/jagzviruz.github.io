{"componentChunkName":"component---src-templates-post-js","path":"/shortest-way-to-form-string","result":{"data":{"markdownRemark":{"html":"<h3 id=\"question\" style=\"position:relative;\"><a href=\"#question\" aria-label=\"question permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Question</h3>\n<p>Given two strings <em>source</em> and <em>target</em>, return the minimum number of subsequences of <em>source</em> such that their concatenation equals <em>target</em>. If the task is impossible, return <em>-1</em>.</p>\n<p><strong>Example 1:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">Input: source = \"abc\", target = \"abcbc\"\nOutput: 2\nExplanation: The target \"abcbc\" can be formed by \"abc\" and \"bc\", which are subsequences of source \"abc\".</code></pre></div>\n<p><strong>Example 2:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">Input: source = \"abc\", target = \"acdbc\"\nOutput: -1\nExplanation: The target string cannot be constructed from the subsequences of source string due to the character \"d\" in target string.</code></pre></div>\n<p><strong>Example 3:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">Input: source = \"xyz\", target = \"xzyxz\"\nOutput: 3\nExplanation: The target string can be constructed as follows \"xz\" + \"y\" + \"xz\".</code></pre></div>\n<h3 id=\"discussion\" style=\"position:relative;\"><a href=\"#discussion\" aria-label=\"discussion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Discussion</h3>\n<p>An exhaustive way of solving this problem would be to generate all subsequences of the <em>source</em> string and then use the array of subsequences to match against parts of the string.\nIt is important to note here that a <strong>subsequence</strong> of a string is a sequqnce of characters picked from the source in the same order they appear in the original string.</p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">For the string \"aecdgga\"\n\n\"ae\", \"adg\", \"da\", \"egg\" are all subsequences.\n\n\"gd\" is not a subsequence.</code></pre></div>\n<p>So the way to solve this problem is to check if characters in the <em>target</em> are appearing in the same order as in the <em>source</em>. So take two pointers, and compare the characters, if they are a match, then move both pointers ahead. When the pointers do not match, increment just the <em>source</em> pointer to see if the character is seen later in the string. If you reach the end of the string, without finding the character, you have to start from the begining of the string again.</p>\n<p>If the second iteration, gives you an empty subsequence, that means the character in the <em>target</em> string is not present in the <em>source</em> string.</p>\n<h3 id=\"solution\" style=\"position:relative;\"><a href=\"#solution\" aria-label=\"solution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Solution</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/**\n * @param {string} source\n * @param {string} target\n * @return {number}\n */</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">shortestWay</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">source<span class=\"token punctuation\">,</span> target</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> numSubsequences <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> remainingPart <span class=\"token operator\">=</span> target<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Initially no part of the target string has been found.</span>\n\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>remainingPart<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//Keep trying to find subsequence as long as there ramaining part is not null</span>\n\n        <span class=\"token keyword\">let</span> subseq <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">/**\n        * Use two pointers to point at source and remainingPart.\n        * If the characters at both pointers match.\n        *  - Append the subsequence from the source\n        *  - Increment both the pointers\n        * If the characters at both pointers do not match,\n        *. - increment only the source pointer\n        *\n        */</span>\n\n        <span class=\"token keyword\">let</span> sourcePointer <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> remainingPartPointer <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>sourcePointer <span class=\"token operator\">&lt;</span> source<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&amp;&amp;</span> remainingPartPointer <span class=\"token operator\">&lt;</span> remainingPart<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">[</span>sourcePointer<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> remainingPart<span class=\"token punctuation\">[</span>remainingPartPointer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                subseq <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>subseq<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>source<span class=\"token punctuation\">[</span>sourcePointer<span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n                remainingPartPointer<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            sourcePointer<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">/**\n        * If at this point subseq is still empty, it means a character was found in the remainingPart\n        * that is not present in source. So this means we can immediately return -1.\n        */</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>subseq<span class=\"token punctuation\">.</span>length <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// A subsequence was found.</span>\n        numSubsequences<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">/**\n        * Now since the subsequence was found, we don't need to check that part.\n        * So we can remove it from the remainingPart and start again.\n        */</span>\n        remainingPart <span class=\"token operator\">=</span> remainingPart<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>subseq<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> numSubsequences<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<iframe height=\"1400px\" width=\"100%\" src=\"https://repl.it/@jagzviruz/Shortest-way-to-form-string?lite=true\" scrolling=\"no\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" sandbox=\"allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals\"></iframe>","frontmatter":{"title":"Shortest way to form a string","date":"2020-08-17T20:28","tags":["javascript","leetcode","two-pointer","subsequence"],"spoiler":"Check if a string was formed by using subsequences from another.","keywords":["javascript","leetcode","two-pointer","subsequence"]}},"site":{"siteMetadata":{"siteUrl":"https://jagadishk.dev","social":{"twitterHandle":"@jagzviruz"}}}},"pageContext":{"slug":"/shortest-way-to-form-string","previous":{"fields":{"slug":"/sorting/selection-sort"},"frontmatter":{"title":"Selection sort"}},"next":{"fields":{"slug":"/lru-cache"},"frontmatter":{"title":"Implementing a LRU Cache in Javascript"}}}},"staticQueryHashes":["436878334","676376647"]}